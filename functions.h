#ifndef SQUARESOLVER_H
#define SQUARESOLVER_H


#include <assert.h>
#include <math.h>
#include <stdio.h>


/*!
\file
\brief Заголовочный файл с описанием библиотечных функций
*/


#define ASSERT(cond)\
    do {            \
	    if (!(cond))\
		    printf("\tError in line %d\n\tof the file %s\n\tcondinion (%s) is false\n", __LINE__, __FILE__, #cond);\
    } while(0)


/*!
	\brief Функция выводит строку в стандартный поток вывода и переходит на новую строку.
	\param[in] line Указатель на выводимую строку.
	\return {1, EOF} В случае успеха и ошибки соответственно.
*/
int PUTS(const char* line);


/*!
	\brief Функция выполняет поиск первого вхождения символа в строку.
	\param[in] str Указатель на строку.
    \param[in] symbol Искомый символ, передается в функцию как целое число.
	\return Указатель на первое вхождение символа в строке.
*/
char* STRCHR(char* str, int symbol);


/*!
	\brief Функция, вычисляющая длину заданной строки.
	\param[in] str Указатель на строку.
	\return Длина строки.
*/
size_t STRLEN(const char* str);


/*!
	\brief Функция копирует строку, включая завершающий нулевой символ в строку назначения, на которую ссылается указатель.
	\param[in] srcpt Указатель на копируемую строку.
    \param[in] destptr Указатель на изменяемую строку.
	\return Указатель на строку назначения.
*/
char* STRCPY (char* destptr, const char* srcpt);


/*!
	\brief Функция копирует первые num символов из строки в строку.
	\param[in] srcpt Указатель на копируемую строку.
    \param[in] destptr Указатель на изменяемую строку.
	\return Указатель на строку назначения.

    Если конец строки srcptr (символ конца строки) достигнут прежде, чем были скопированы num символов, к скопированным символам в конец строки destptr добавляется нуль-символ, после чего строка считается скопированной.
    Если же строка назначения окажется меньше num, тогда скопируются символы, которые поместятся в destptr, учитывая то, что в конце строки обязательно должен стоять символ конца строки.
*/
char* STRNCPY (char* destptr, const char* srcpt, size_t num);


/*!
	\brief Функция добавляет копию строки srcptr в конец строки destptr.
	\param[in] srcptr Указатель на копируемую строку.
    \param[in] destptr Указатель на изменяемую строку.
	\return Указатель на строку назначения.

    Нулевой символ конца строки destptr заменяется первым символом строки srcptr, и новый нуль-символ добавляется в конец уже новой строки, сформированной объединением символов двух строк в строке destptr.
*/
char* STRCAT(char* destptr, const char* srcptr);


/*!
	\brief Функция добавляет первые num символов строки srcptr к концу строки destptr, плюс символ конца строки.
	\param[in] srcpt Указатель на копируемую строку.
    \param[in] destptr Указатель на изменяемую строку.
    \param[in] num Максимальное количество символов для конкатенации.
	\return Указатель на строку назначения.

    Если строка srcptr больше чем количество копируемых символов num, то после скопированных символов неявно добавляется символ конца строки.
*/
char* STRNCAT(char* destptr, const char* srcptr, size_t num);


/*!
	\brief Функция fgets считывает символы из файла и сохраняет их в виде строки в параметр str.
	\param[in] str Указатель на массив, в который сохраняются считанные символы.
    \param[in] num Максимальное количество символов для чтения, включая нулевой символ.
    \param[in] stream Указатель, который идентифицирует поток, из которого считываются символы.
	\return Указатель на строку назначения(NULL в случае ошибки)

    Символ новой строки прекращает работу функции fgets, но он считается допустимым символом, и поэтому он копируется в строку str.

    Нулевой символ автоматически добавляется в строку str после прочитанных символов, чтобы сигнализировать о конце строки.
*/
char* FGETS(char* str, int num, FILE* stream);


/*!
	\brief Функция копирует строку, на которую указывает аргумент.
	\param[in] str Указатель на копируемую строку.
	\return Указатель на строку назначения(NULL в случае ошибки)

    Память под дубликат строки выделяется с помощью функции malloc, и по окончанию работы с дубликатом должна быть очищена с помощью функции free.
*/
char* STRDUP(const char* str);


/*!
	\brief Функция считывает целую строку, сохраняя адрес буфера, содержащего текст, в *lineptr.
	\param[in] str Указатель на копируемую строку.
    \param[in] lineptr Двойной указатель на копируемую строку.
    \param[in] stream Указатель на файловый поток.
	\return Указатель на строку назначения(NULL в случае ошибки)

    Буфер завершается null и содержит символ новой строки, если был найден разделитель для новой строки.

    Если *lineptr равно NULL, то процедура будет создавать буфер для содержимого строки, который затем должен быть высвобожден программой пользователя. В любом случае при успешном вызове *lineptr и *num будут обновлены для отражения адреса буфера и его размера соответственно.
*/
size_t GETLINE(char** lineptr, size_t* num, FILE* stream);


#endif